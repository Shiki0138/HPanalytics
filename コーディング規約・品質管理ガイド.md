# AIウェブ分析システム コーディング規約・品質管理ガイド

## 目次
1. [コーディング規約](#1-コーディング規約)
2. [ビルドエラー防止策](#2-ビルドエラー防止策)
3. [品質管理プロセス](#3-品質管理プロセス)
4. [自動化ツール設定](#4-自動化ツール設定)
5. [コードレビューガイドライン](#5-コードレビューガイドライン)

---

## 1. コーディング規約

### 1.1 JavaScript/TypeScript 規約

#### 命名規則
```typescript
// ✅ 良い例
// 変数・関数: camelCase
const userName = 'John Doe';
const calculateTotalPrice = (items: Item[]) => {};

// 定数: UPPER_SNAKE_CASE
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = 'https://api.example.com';

// クラス・型・インターフェース: PascalCase
class UserAnalytics {}
type UserData = {};
interface IApiResponse {}

// ファイル名
// - コンポーネント: PascalCase.tsx
// - ユーティリティ: camelCase.ts
// - 定数: constants.ts
// - 型定義: types.ts

// ❌ 悪い例
const user_name = 'John';  // snake_case は使わない
const getdata = () => {};   // 意味のある名前にする
const temp = {};            // 一時変数でも意味のある名前を
```

#### 関数の書き方
```typescript
// ✅ 良い例: 明確な型定義と単一責任
interface UserStats {
  pageViews: number;
  sessions: number;
  bounceRate: number;
}

async function fetchUserStats(userId: string, dateRange: DateRange): Promise<UserStats> {
  try {
    const response = await api.get(`/users/${userId}/stats`, {
      params: { startDate: dateRange.start, endDate: dateRange.end }
    });
    
    return {
      pageViews: response.data.pageViews,
      sessions: response.data.sessions,
      bounceRate: response.data.bounceRate
    };
  } catch (error) {
    logger.error('Failed to fetch user stats', { userId, error });
    throw new ApiError('ユーザー統計の取得に失敗しました', error);
  }
}

// ❌ 悪い例: 型定義なし、エラーハンドリングなし
function getUserData(id) {
  return fetch(`/api/users/${id}`).then(res => res.json());
}
```

#### 条件分岐とガード句
```typescript
// ✅ 良い例: 早期リターンでネストを減らす
function processUserData(user: User | null): ProcessedData | null {
  // ガード句で異常系を先に処理
  if (!user) {
    logger.warn('User is null');
    return null;
  }
  
  if (!user.isActive) {
    logger.info('User is not active', { userId: user.id });
    return null;
  }
  
  // メインの処理
  return {
    id: user.id,
    name: user.name,
    lastActive: user.lastLoginAt
  };
}

// ❌ 悪い例: 深いネスト
function processUserData(user: User | null) {
  if (user) {
    if (user.isActive) {
      return {
        id: user.id,
        name: user.name
      };
    } else {
      return null;
    }
  } else {
    return null;
  }
}
```

### 1.2 React コンポーネント規約

#### コンポーネント構造
```tsx
// ✅ 良い例: 明確な構造と型定義
import React, { useState, useEffect, useCallback, memo } from 'react';
import { Box, Typography, CircularProgress } from '@mui/material';
import { useAnalytics } from '@/hooks/useAnalytics';
import { MetricCard } from '@/components/MetricCard';
import type { DashboardProps, Metric } from '@/types';

export const Dashboard: React.FC<DashboardProps> = memo(({ userId, timeRange }) => {
  // 1. State定義（関連するものをグループ化）
  const [metrics, setMetrics] = useState<Metric[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  // 2. カスタムフックの使用
  const { fetchMetrics } = useAnalytics();
  
  // 3. useCallbackでメモ化
  const loadMetrics = useCallback(async () => {
    try {
      setLoading(true);
      const data = await fetchMetrics(userId, timeRange);
      setMetrics(data);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [userId, timeRange, fetchMetrics]);
  
  // 4. useEffectは最小限の依存関係
  useEffect(() => {
    loadMetrics();
  }, [loadMetrics]);
  
  // 5. 条件付きレンダリング
  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={4}>
        <CircularProgress />
      </Box>
    );
  }
  
  if (error) {
    return (
      <Box p={4}>
        <Typography color="error">
          エラーが発生しました: {error.message}
        </Typography>
      </Box>
    );
  }
  
  // 6. メインのレンダリング
  return (
    <Box p={3}>
      <Typography variant="h4" mb={3}>
        ダッシュボード
      </Typography>
      <Box display="grid" gridTemplateColumns="repeat(auto-fit, minmax(250px, 1fr))" gap={3}>
        {metrics.map(metric => (
          <MetricCard key={metric.id} metric={metric} />
        ))}
      </Box>
    </Box>
  );
});

Dashboard.displayName = 'Dashboard';
```

#### カスタムフックの作成
```typescript
// ✅ 良い例: 再利用可能なロジックの抽出
import { useState, useEffect, useCallback } from 'react';
import { analyticsApi } from '@/services/api';
import type { AnalyticsData, TimeRange } from '@/types';

export function useAnalytics(siteId: string) {
  const [data, setData] = useState<AnalyticsData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const fetchData = useCallback(async (timeRange: TimeRange) => {
    try {
      setLoading(true);
      setError(null);
      const response = await analyticsApi.getAnalytics(siteId, timeRange);
      setData(response.data);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [siteId]);
  
  const refetch = useCallback(() => {
    if (data?.timeRange) {
      fetchData(data.timeRange);
    }
  }, [data, fetchData]);
  
  return {
    data,
    loading,
    error,
    fetchData,
    refetch
  };
}
```

### 1.3 CSS/スタイリング規約

#### CSS Modules の使用
```scss
// Dashboard.module.scss
.container {
  padding: 24px;
  background-color: var(--bg-primary);
  
  @media (max-width: 768px) {
    padding: 16px;
  }
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  
  &__title {
    font-size: 24px;
    font-weight: 600;
    color: var(--text-primary);
  }
  
  &__actions {
    display: flex;
    gap: 12px;
  }
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 24px;
  
  &--compact {
    gap: 16px;
  }
}
```

#### Emotion/styled-components の使用
```tsx
// ✅ 良い例: テーマとpropsを活用
import styled from '@emotion/styled';
import { css } from '@emotion/react';

interface CardProps {
  variant?: 'default' | 'highlighted';
  isClickable?: boolean;
}

export const Card = styled.div<CardProps>`
  padding: ${({ theme }) => theme.spacing(3)};
  background-color: ${({ theme }) => theme.palette.background.paper};
  border-radius: ${({ theme }) => theme.shape.borderRadius}px;
  box-shadow: ${({ theme }) => theme.shadows[1]};
  transition: all 0.2s ease-in-out;
  
  ${({ variant, theme }) => variant === 'highlighted' && css`
    border: 2px solid ${theme.palette.primary.main};
    background-color: ${theme.palette.primary.light};
  `}
  
  ${({ isClickable }) => isClickable && css`
    cursor: pointer;
    
    &:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
  `}
`;
```

---

## 2. ビルドエラー防止策

### 2.1 Pre-commit フックの設定

#### Husky + lint-staged
```json
// package.json
{
  "scripts": {
    "prepare": "husky install",
    "pre-commit": "lint-staged"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md,yml}": [
      "prettier --write"
    ],
    "*.{css,scss}": [
      "stylelint --fix",
      "prettier --write"
    ]
  }
}
```

#### .husky/pre-commit
```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# 型チェック
echo "🔍 型チェックを実行しています..."
npm run type-check
if [ $? -ne 0 ]; then
  echo "❌ TypeScriptの型エラーがあります。修正してください。"
  exit 1
fi

# ESLint
echo "🔍 ESLintチェックを実行しています..."
npm run lint
if [ $? -ne 0 ]; then
  echo "❌ ESLintエラーがあります。修正してください。"
  exit 1
fi

# テスト
echo "🧪 テストを実行しています..."
npm run test -- --passWithNoTests
if [ $? -ne 0 ]; then
  echo "❌ テストが失敗しました。修正してください。"
  exit 1
fi

# ビルド確認
echo "🏗️  ビルドチェックを実行しています..."
npm run build
if [ $? -ne 0 ]; then
  echo "❌ ビルドエラーがあります。修正してください。"
  exit 1
fi

echo "✅ すべてのチェックが成功しました！"
```

### 2.2 TypeScript 厳格設定

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "esnext",
    "jsx": "react-jsx",
    
    // 型チェックの厳格化
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    
    // 追加のチェック
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    
    // モジュール解決
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": false,
    
    // 出力設定
    "noEmit": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": ["src/**/*", "types/**/*"],
  "exclude": ["node_modules", "build", "dist"]
}
```

### 2.3 エラー予防のための型定義

```typescript
// types/common.ts
// ✅ 良い例: 厳格な型定義

// ユーティリティ型
export type Nullable<T> = T | null;
export type Optional<T> = T | undefined;
export type AsyncReturnType<T extends (...args: any) => Promise<any>> = 
  T extends (...args: any) => Promise<infer R> ? R : never;

// 共通の型定義
export interface ApiResponse<T> {
  success: boolean;
  data: T;
  error?: {
    code: string;
    message: string;
    details?: unknown;
  };
  metadata?: {
    timestamp: string;
    version: string;
  };
}

// 厳格なイベントハンドラー型
export type ClickHandler<T = HTMLElement> = (event: React.MouseEvent<T>) => void;
export type ChangeHandler<T = HTMLInputElement> = (event: React.ChangeEvent<T>) => void;
export type SubmitHandler = (event: React.FormEvent<HTMLFormElement>) => void;

// APIエラーの型定義
export class ApiError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number,
    public details?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// 型ガード関数
export function isApiError(error: unknown): error is ApiError {
  return error instanceof ApiError;
}

export function isNotNull<T>(value: T | null): value is T {
  return value !== null;
}

export function isDefined<T>(value: T | undefined): value is T {
  return value !== undefined;
}
```

---

## 3. 品質管理プロセス

### 3.1 テスト戦略

#### 単体テストのベストプラクティス
```typescript
// UserAnalytics.test.ts
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { UserAnalytics } from './UserAnalytics';
import { analyticsApi } from '@/services/api';
import { mockAnalyticsData } from '@/test/fixtures';

// モックの設定
jest.mock('@/services/api');
const mockedApi = analyticsApi as jest.Mocked<typeof analyticsApi>;

describe('UserAnalytics', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  describe('データ取得', () => {
    it('初期ロード時にデータを取得する', async () => {
      // Arrange
      mockedApi.getUserAnalytics.mockResolvedValueOnce({
        data: mockAnalyticsData
      });
      
      // Act
      render(<UserAnalytics userId="user123" />);
      
      // Assert
      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
      
      await waitFor(() => {
        expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();
      });
      
      expect(mockedApi.getUserAnalytics).toHaveBeenCalledWith('user123', {
        startDate: expect.any(String),
        endDate: expect.any(String)
      });
      
      expect(screen.getByText('ページビュー: 1,234')).toBeInTheDocument();
    });
    
    it('エラー時にエラーメッセージを表示する', async () => {
      // Arrange
      const errorMessage = 'データの取得に失敗しました';
      mockedApi.getUserAnalytics.mockRejectedValueOnce(
        new Error(errorMessage)
      );
      
      // Act
      render(<UserAnalytics userId="user123" />);
      
      // Assert
      await waitFor(() => {
        expect(screen.getByText(errorMessage)).toBeInTheDocument();
      });
      
      expect(screen.queryByTestId('analytics-data')).not.toBeInTheDocument();
    });
  });
  
  describe('ユーザーインタラクション', () => {
    it('リフレッシュボタンでデータを再取得する', async () => {
      // Arrange
      mockedApi.getUserAnalytics.mockResolvedValue({
        data: mockAnalyticsData
      });
      
      render(<UserAnalytics userId="user123" />);
      
      await waitFor(() => {
        expect(screen.getByTestId('analytics-data')).toBeInTheDocument();
      });
      
      // Act
      const refreshButton = screen.getByRole('button', { name: '更新' });
      await userEvent.click(refreshButton);
      
      // Assert
      expect(mockedApi.getUserAnalytics).toHaveBeenCalledTimes(2);
    });
  });
});
```

#### 統合テストの例
```typescript
// api.integration.test.ts
import { createTestServer } from '@/test/utils';
import { createTestDatabase } from '@/test/database';
import request from 'supertest';

describe('Analytics API Integration', () => {
  let server: any;
  let db: any;
  
  beforeAll(async () => {
    db = await createTestDatabase();
    server = await createTestServer(db);
  });
  
  afterAll(async () => {
    await db.close();
    await server.close();
  });
  
  describe('POST /api/analytics/track', () => {
    it('正常なトラッキングデータを受け付ける', async () => {
      // Arrange
      const trackingData = {
        eventType: 'pageview',
        url: 'https://example.com/products',
        timestamp: new Date().toISOString(),
        sessionId: 'session123'
      };
      
      // Act
      const response = await request(server)
        .post('/api/analytics/track')
        .set('X-Tracking-ID', 'valid-tracking-id')
        .send(trackingData);
      
      // Assert
      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        eventId: expect.any(String)
      });
      
      // データベースに保存されていることを確認
      const savedEvent = await db.collection('events').findOne({
        sessionId: 'session123'
      });
      
      expect(savedEvent).toMatchObject({
        eventType: 'pageview',
        url: 'https://example.com/products'
      });
    });
    
    it('不正なトラッキングIDを拒否する', async () => {
      // Act
      const response = await request(server)
        .post('/api/analytics/track')
        .set('X-Tracking-ID', 'invalid-id')
        .send({});
      
      // Assert
      expect(response.status).toBe(401);
      expect(response.body.error.code).toBe('INVALID_TRACKING_ID');
    });
  });
});
```

### 3.2 パフォーマンス監視

```typescript
// utils/performance.ts
export class PerformanceMonitor {
  private marks: Map<string, number> = new Map();
  
  mark(name: string): void {
    this.marks.set(name, performance.now());
  }
  
  measure(name: string, startMark: string, endMark?: string): number {
    const start = this.marks.get(startMark);
    if (!start) {
      throw new Error(`Mark ${startMark} not found`);
    }
    
    const end = endMark ? this.marks.get(endMark) : performance.now();
    if (!end) {
      throw new Error(`Mark ${endMark} not found`);
    }
    
    const duration = end - start;
    
    // パフォーマンス警告
    if (duration > 1000) {
      console.warn(`Performance warning: ${name} took ${duration.toFixed(2)}ms`);
    }
    
    // メトリクスの送信（本番環境）
    if (process.env.NODE_ENV === 'production') {
      this.sendMetrics(name, duration);
    }
    
    return duration;
  }
  
  private sendMetrics(name: string, duration: number): void {
    // Analytics APIに送信
    if (window.analytics) {
      window.analytics.track('Performance Metric', {
        metric: name,
        duration,
        url: window.location.href,
        userAgent: navigator.userAgent
      });
    }
  }
}

// 使用例
export function measureApiCall<T>(
  name: string,
  apiCall: () => Promise<T>
): Promise<T> {
  const monitor = new PerformanceMonitor();
  monitor.mark(`${name}-start`);
  
  return apiCall()
    .then(result => {
      monitor.measure(name, `${name}-start`);
      return result;
    })
    .catch(error => {
      monitor.measure(`${name}-error`, `${name}-start`);
      throw error;
    });
}
```

### 3.3 エラー監視とロギング

```typescript
// utils/logger.ts
import * as Sentry from '@sentry/react';

export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error'
}

interface LogContext {
  userId?: string;
  sessionId?: string;
  [key: string]: any;
}

class Logger {
  private isDevelopment = process.env.NODE_ENV === 'development';
  
  private log(level: LogLevel, message: string, context?: LogContext): void {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      ...context
    };
    
    // コンソール出力（開発環境）
    if (this.isDevelopment) {
      console[level](message, context);
    }
    
    // Sentryへの送信（本番環境）
    if (!this.isDevelopment && level === LogLevel.ERROR) {
      Sentry.captureException(new Error(message), {
        level: 'error',
        extra: context
      });
    }
    
    // 構造化ログの送信
    this.sendToLogService(logEntry);
  }
  
  private sendToLogService(logEntry: any): void {
    // CloudWatch Logs や Datadog などへの送信
    if (window.navigator.sendBeacon) {
      window.navigator.sendBeacon(
        '/api/logs',
        JSON.stringify(logEntry)
      );
    }
  }
  
  debug(message: string, context?: LogContext): void {
    this.log(LogLevel.DEBUG, message, context);
  }
  
  info(message: string, context?: LogContext): void {
    this.log(LogLevel.INFO, message, context);
  }
  
  warn(message: string, context?: LogContext): void {
    this.log(LogLevel.WARN, message, context);
  }
  
  error(message: string, error?: Error, context?: LogContext): void {
    const errorContext = {
      ...context,
      errorMessage: error?.message,
      errorStack: error?.stack,
      errorName: error?.name
    };
    
    this.log(LogLevel.ERROR, message, errorContext);
  }
}

export const logger = new Logger();

// エラーバウンダリーの実装
export class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(): { hasError: boolean } {
    return { hasError: true };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    logger.error('React Error Boundary caught an error', error, {
      componentStack: errorInfo.componentStack
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>申し訳ございません。エラーが発生しました。</h2>
          <button onClick={() => window.location.reload()}>
            ページを再読み込み
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

---

## 4. 自動化ツール設定

### 4.1 ESLint 詳細設定

```javascript
// .eslintrc.js
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    },
    project: './tsconfig.json'
  },
  env: {
    browser: true,
    es2022: true,
    node: true,
    jest: true
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:@typescript-eslint/recommended-requiring-type-checking',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:jsx-a11y/recommended',
    'plugin:import/errors',
    'plugin:import/warnings',
    'plugin:import/typescript',
    'plugin:jest/recommended',
    'plugin:testing-library/react',
    'plugin:cypress/recommended',
    'prettier'
  ],
  plugins: [
    '@typescript-eslint',
    'react',
    'react-hooks',
    'jsx-a11y',
    'import',
    'jest',
    'testing-library',
    'cypress'
  ],
  settings: {
    react: {
      version: 'detect'
    },
    'import/resolver': {
      typescript: {
        alwaysTryTypes: true
      }
    }
  },
  rules: {
    // TypeScript
    '@typescript-eslint/explicit-function-return-type': ['error', {
      allowExpressions: true,
      allowTypedFunctionExpressions: true
    }],
    '@typescript-eslint/no-unused-vars': ['error', {
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_'
    }],
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/no-non-null-assertion': 'error',
    '@typescript-eslint/strict-boolean-expressions': ['error', {
      allowString: false,
      allowNumber: false
    }],
    
    // React
    'react/prop-types': 'off',
    'react/react-in-jsx-scope': 'off',
    'react/jsx-uses-react': 'off',
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn',
    
    // Import
    'import/order': ['error', {
      groups: [
        'builtin',
        'external',
        'internal',
        'parent',
        'sibling',
        'index',
        'object',
        'type'
      ],
      'newlines-between': 'always',
      alphabetize: {
        order: 'asc',
        caseInsensitive: true
      }
    }],
    'import/no-duplicates': 'error',
    'import/no-cycle': 'error',
    
    // 一般
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    'no-debugger': 'error',
    'no-alert': 'error',
    'prefer-const': 'error',
    'no-var': 'error',
    'object-shorthand': 'error',
    'prefer-template': 'error',
    'prefer-destructuring': ['error', {
      array: true,
      object: true
    }],
    
    // コードの複雑さ
    'complexity': ['error', 10],
    'max-depth': ['error', 3],
    'max-lines': ['error', {
      max: 300,
      skipBlankLines: true,
      skipComments: true
    }],
    'max-lines-per-function': ['error', {
      max: 50,
      skipBlankLines: true,
      skipComments: true
    }]
  },
  overrides: [
    {
      files: ['**/*.test.ts', '**/*.test.tsx'],
      rules: {
        '@typescript-eslint/no-explicit-any': 'off',
        'max-lines-per-function': 'off'
      }
    }
  ]
};
```

### 4.2 Prettier 設定

```javascript
// .prettierrc.js
module.exports = {
  // 基本設定
  printWidth: 100,
  tabWidth: 2,
  useTabs: false,
  semi: true,
  singleQuote: true,
  quoteProps: 'as-needed',
  jsxSingleQuote: false,
  trailingComma: 'es5',
  bracketSpacing: true,
  bracketSameLine: false,
  arrowParens: 'avoid',
  
  // 言語別設定
  overrides: [
    {
      files: '*.json',
      options: {
        printWidth: 80
      }
    },
    {
      files: '*.md',
      options: {
        proseWrap: 'always'
      }
    },
    {
      files: ['*.yml', '*.yaml'],
      options: {
        singleQuote: false
      }
    }
  ]
};
```

### 4.3 Jest 設定

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/src'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/?(*.)+(spec|test).+(ts|tsx|js)'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', {
      tsconfig: {
        jsx: 'react'
      }
    }]
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/__mocks__/fileMock.js'
  },
  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
    '!src/test/**/*'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  globals: {
    'ts-jest': {
      isolatedModules: true
    }
  }
};
```

---

## 5. コードレビューガイドライン

### 5.1 レビューチェックリスト

```markdown
## コードレビューチェックリスト

### 🏗️ アーキテクチャ・設計
- [ ] 単一責任の原則に従っているか
- [ ] 適切な抽象化レベルか
- [ ] 再利用可能な設計か
- [ ] 将来の拡張性を考慮しているか

### 💻 コード品質
- [ ] 命名規則に従っているか
- [ ] 不要なコメントアウトがないか
- [ ] マジックナンバーが定数化されているか
- [ ] 重複コードがないか
- [ ] 複雑度が適切か（循環的複雑度 < 10）

### 🔒 セキュリティ
- [ ] 入力値の検証が適切か
- [ ] SQLインジェクション対策がされているか
- [ ] XSS対策がされているか
- [ ] 認証・認可が適切か
- [ ] センシティブ情報がハードコードされていないか

### ⚡ パフォーマンス
- [ ] N+1問題がないか
- [ ] 適切なインデックスが設定されているか
- [ ] 不要な再レンダリングがないか
- [ ] 適切なメモ化がされているか
- [ ] バンドルサイズへの影響は妥当か

### 🧪 テスト
- [ ] テストが書かれているか
- [ ] テストケースが網羅的か
- [ ] エッジケースがカバーされているか
- [ ] モックが適切か
- [ ] テストが保守しやすいか

### 📚 ドキュメント
- [ ] 関数・クラスにJSDocコメントがあるか
- [ ] 複雑なロジックに説明があるか
- [ ] READMEが更新されているか
- [ ] 破壊的変更が明記されているか

### 🎯 その他
- [ ] エラーハンドリングが適切か
- [ ] ログ出力が適切か
- [ ] 国際化対応が考慮されているか
- [ ] アクセシビリティが考慮されているか
```

### 5.2 レビューコメントの書き方

```markdown
## 良いレビューコメントの例

### 🟢 建設的なフィードバック
```
// 提案
このロジックは `useMemo` でメモ化すると、不要な再計算を防げます：

```typescript
const expensiveValue = useMemo(() => {
  return calculateExpensiveValue(data);
}, [data]);
```

パフォーマンスが改善される可能性があります。
```

### 🟢 具体的な改善案
```
// セキュリティの観点
ユーザー入力を直接SQLクエリに含めるのは危険です。
パラメータ化クエリを使用しましょう：

```typescript
// Before
db.query(`SELECT * FROM users WHERE id = ${userId}`);

// After
db.query('SELECT * FROM users WHERE id = ?', [userId]);
```
```

### 🔴 避けるべきコメント
```
// ❌ 曖昧
"このコードは良くない"

// ❌ 個人的な好み
"私ならこう書く"

// ❌ 批判的
"なぜこんな書き方をしたの？"
```

### 5.3 レビュー対応のベストプラクティス

```markdown
## レビュー対応の流れ

1. **全てのコメントに返信する**
   - 対応した: "修正しました 👍"
   - 議論が必要: "この実装にした理由は..."
   - 別PRで対応: "別のPRで対応します（Issue #123）"

2. **コミットメッセージで対応内容を明確に**
   ```
   fix: レビュー指摘事項の修正
   
   - メモリリークの修正
   - エラーハンドリングの追加
   - テストケースの追加
   ```

3. **大きな変更は事前に相談**
   - Slackで設計について議論
   - 必要に応じてペアプロ/モブプロ

4. **マージ前の最終確認**
   - CI/CDが全て緑
   - コンフリクトが解決済み
   - レビュー承認が必要数取得済み
```

---

この品質管理ガイドラインに従うことで、高品質で保守性の高いコードベースを維持できます。