name: CI/CD Pipeline

on:
  push:
    branches: [main, develop, staging]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      rollback:
        description: 'Rollback to previous version'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-west-2
  ECR_REGISTRY: ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.us-west-2.amazonaws.com
  NODE_VERSION: 18
  PYTHON_VERSION: 3.9

jobs:
  # Pre-flight checks
  pre-flight:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      should-deploy: ${{ steps.determine-env.outputs.should-deploy }}
      image-tag: ${{ steps.generate-tag.outputs.tag }}
    steps:
      - name: Determine Environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate Image Tag
        id: generate-tag
        run: |
          if [[ "${{ steps.determine-env.outputs.environment }}" == "production" ]]; then
            echo "tag=prod-${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=staging-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  # Code Quality and Testing
  test:
    runs-on: ubuntu-latest
    needs: pre-flight
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 3s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install Dependencies
        run: npm ci
      
      - name: Run ESLint
        run: npm run lint
      
      - name: Run TypeScript Check
        run: npm run type-check
      
      - name: Run Unit Tests
        run: npm run test:unit
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379
      
      - name: Run Integration Tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379
      
      - name: Generate Test Coverage
        run: npm run test:coverage
      
      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: true

  # AI Engine Tests
  test-ai-engine:
    runs-on: ubuntu-latest
    needs: pre-flight
    defaults:
      run:
        working-directory: ./ai-engine
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: Run Python Tests
        run: pytest --cov=. --cov-report=xml
      
      - name: Upload AI Engine Coverage
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./ai-engine/coverage.xml
          flags: ai-engine

  # Security Scanning
  security:
    runs-on: ubuntu-latest
    needs: pre-flight
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Run Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'hp-analysis-system'
          path: '.'
          format: 'ALL'
          args: >
            --enableRetired
            --enableExperimental
      
      - name: Upload Dependency Check Results
        uses: actions/upload-artifact@v3
        with:
          name: dependency-check-report
          path: reports/
      
      - name: Run Trivy Container Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy Scan Results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Build and Push Docker Images
  build-and-push:
    runs-on: ubuntu-latest
    needs: [pre-flight, test, test-ai-engine]
    if: needs.pre-flight.outputs.should-deploy == 'true'
    strategy:
      matrix:
        service: [app, ai-engine]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and Push App Image
        if: matrix.service == 'app'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.ECR_REGISTRY }}/hp-analysis-${{ needs.pre-flight.outputs.environment }}-app:${{ needs.pre-flight.outputs.image-tag }}
            ${{ env.ECR_REGISTRY }}/hp-analysis-${{ needs.pre-flight.outputs.environment }}-app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}
      
      - name: Build and Push AI Engine Image
        if: matrix.service == 'ai-engine'
        uses: docker/build-push-action@v5
        with:
          context: ./ai-engine
          file: ./ai-engine/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.ECR_REGISTRY }}/hp-analysis-${{ needs.pre-flight.outputs.environment }}-ai-engine:${{ needs.pre-flight.outputs.image-tag }}
            ${{ env.ECR_REGISTRY }}/hp-analysis-${{ needs.pre-flight.outputs.environment }}-ai-engine:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENVIRONMENT=production
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}
      
      - name: Scan Docker Image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.ECR_REGISTRY }}/hp-analysis-${{ needs.pre-flight.outputs.environment }}-${{ matrix.service }}:${{ needs.pre-flight.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-image-results.sarif'
      
      - name: Upload Image Scan Results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-image-results.sarif'

  # Database Migrations
  migrate:
    runs-on: ubuntu-latest
    needs: [pre-flight, build-and-push]
    if: needs.pre-flight.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install Dependencies
        run: npm ci
      
      - name: Get Database URL from Secrets Manager
        id: get-db-url
        run: |
          DB_SECRET=$(aws secretsmanager get-secret-value \
            --secret-id hp-analysis-${{ needs.pre-flight.outputs.environment }}-db-credentials \
            --query SecretString --output text)
          
          DB_HOST=$(echo $DB_SECRET | jq -r .host)
          DB_PORT=$(echo $DB_SECRET | jq -r .port)
          DB_NAME=$(echo $DB_SECRET | jq -r .dbname)
          DB_USER=$(echo $DB_SECRET | jq -r .username)
          DB_PASSWORD=$(echo $DB_SECRET | jq -r .password)
          
          DATABASE_URL="postgresql://$DB_USER:$DB_PASSWORD@$DB_HOST:$DB_PORT/$DB_NAME"
          echo "::add-mask::$DATABASE_URL"
          echo "database_url=$DATABASE_URL" >> $GITHUB_OUTPUT
      
      - name: Run Database Migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: ${{ steps.get-db-url.outputs.database_url }}
      
      - name: Generate Prisma Client
        run: npx prisma generate
        env:
          DATABASE_URL: ${{ steps.get-db-url.outputs.database_url }}

  # Blue-Green Deployment
  deploy:
    runs-on: ubuntu-latest
    needs: [pre-flight, migrate]
    if: needs.pre-flight.outputs.should-deploy == 'true' && github.event.inputs.rollback != 'true'
    environment:
      name: ${{ needs.pre-flight.outputs.environment }}
      url: https://${{ needs.pre-flight.outputs.environment == 'production' && vars.PRODUCTION_DOMAIN || vars.STAGING_DOMAIN }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get Current ECS Service Configuration
        id: current-config
        run: |
          CLUSTER_NAME="hp-analysis-${{ needs.pre-flight.outputs.environment }}-cluster"
          SERVICE_NAME="hp-analysis-${{ needs.pre-flight.outputs.environment }}-app"
          
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].taskDefinition' --output text)
          
          echo "current_task_definition=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
      
      - name: Create New Task Definition
        id: new-task-def
        run: |
          # Get current task definition
          CURRENT_TASK_DEF="${{ steps.current-config.outputs.current_task_definition }}"
          
          # Download current task definition
          aws ecs describe-task-definition \
            --task-definition $CURRENT_TASK_DEF \
            --query taskDefinition > task-def.json
          
          # Remove unwanted fields
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' task-def.json > cleaned-task-def.json
          
          # Update image URLs
          NEW_APP_IMAGE="${{ env.ECR_REGISTRY }}/hp-analysis-${{ needs.pre-flight.outputs.environment }}-app:${{ needs.pre-flight.outputs.image-tag }}"
          
          jq --arg new_image "$NEW_APP_IMAGE" '
            .containerDefinitions |= map(
              if .name == "app" then
                .image = $new_image
              else . end
            )
          ' cleaned-task-def.json > new-task-def.json
          
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          
          echo "new_task_definition_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
      
      - name: Blue-Green Deployment
        id: blue-green-deploy
        run: |
          CLUSTER_NAME="${{ steps.current-config.outputs.cluster_name }}"
          SERVICE_NAME="${{ steps.current-config.outputs.service_name }}"
          NEW_TASK_DEF="${{ steps.new-task-def.outputs.new_task_definition_arn }}"
          
          echo "Starting blue-green deployment..."
          echo "Cluster: $CLUSTER_NAME"
          echo "Service: $SERVICE_NAME"
          echo "New Task Definition: $NEW_TASK_DEF"
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $NEW_TASK_DEF \
            --deployment-configuration maximumPercent=200,minimumHealthyPercent=100
          
          echo "Deployment started. Waiting for deployment to complete..."
          
          # Wait for deployment to complete
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME
          
          echo "Blue-green deployment completed successfully!"
      
      - name: Deploy AI Engine Service
        run: |
          CLUSTER_NAME="hp-analysis-${{ needs.pre-flight.outputs.environment }}-cluster"
          AI_SERVICE_NAME="hp-analysis-${{ needs.pre-flight.outputs.environment }}-ai-engine"
          
          # Get current AI engine task definition
          CURRENT_AI_TASK_DEF=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $AI_SERVICE_NAME \
            --query 'services[0].taskDefinition' --output text)
          
          # Download and update AI engine task definition
          aws ecs describe-task-definition \
            --task-definition $CURRENT_AI_TASK_DEF \
            --query taskDefinition > ai-task-def.json
          
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' ai-task-def.json > cleaned-ai-task-def.json
          
          NEW_AI_IMAGE="${{ env.ECR_REGISTRY }}/hp-analysis-${{ needs.pre-flight.outputs.environment }}-ai-engine:${{ needs.pre-flight.outputs.image-tag }}"
          
          jq --arg new_image "$NEW_AI_IMAGE" '
            .containerDefinitions |= map(
              if .name == "ai-engine" then
                .image = $new_image
              else . end
            )
          ' cleaned-ai-task-def.json > new-ai-task-def.json
          
          # Register and deploy AI engine
          NEW_AI_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-ai-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $AI_SERVICE_NAME \
            --task-definition $NEW_AI_TASK_DEF_ARN
          
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $AI_SERVICE_NAME
      
      - name: Invalidate CloudFront Cache
        run: |
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='CloudFront distribution for HP Analysis System'].Id" \
            --output text)
          
          if [ -n "$DISTRIBUTION_ID" ]; then
            aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/*"
            echo "CloudFront cache invalidated for distribution: $DISTRIBUTION_ID"
          fi

  # Post-Deployment Tests
  post-deploy-tests:
    runs-on: ubuntu-latest
    needs: [pre-flight, deploy]
    if: needs.pre-flight.outputs.should-deploy == 'true' && github.event.inputs.rollback != 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install Dependencies
        run: npm ci
      
      - name: Run Health Checks
        run: |
          if [[ "${{ needs.pre-flight.outputs.environment }}" == "production" ]]; then
            BASE_URL="https://${{ vars.PRODUCTION_DOMAIN }}"
          else
            BASE_URL="https://${{ vars.STAGING_DOMAIN }}"
          fi
          
          echo "Running health checks against: $BASE_URL"
          
          # Health check
          curl -f "$BASE_URL/health" || exit 1
          
          # API health check
          curl -f "$BASE_URL/api/health" || exit 1
          
          # AI engine health check
          curl -f "$BASE_URL/api/ai/health" || exit 1
          
          echo "All health checks passed!"
      
      - name: Run Smoke Tests
        run: npm run test:smoke
        env:
          BASE_URL: ${{ needs.pre-flight.outputs.environment == 'production' && vars.PRODUCTION_DOMAIN || vars.STAGING_DOMAIN }}
      
      - name: Performance Test
        run: |
          # Install artillery for load testing
          npm install -g artillery
          
          # Run basic performance test
          echo "config:
            target: 'https://${{ needs.pre-flight.outputs.environment == 'production' && vars.PRODUCTION_DOMAIN || vars.STAGING_DOMAIN }}'
            phases:
              - duration: 60
                arrivalRate: 10
          scenarios:
            - name: 'Health check'
              requests:
                - get:
                    url: '/health'
            - name: 'API health check'
              requests:
                - get:
                    url: '/api/health'" > perf-test.yml
          
          artillery run perf-test.yml

  # Rollback
  rollback:
    runs-on: ubuntu-latest
    needs: [pre-flight]
    if: github.event.inputs.rollback == 'true'
    environment:
      name: ${{ needs.pre-flight.outputs.environment }}
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Rollback to Previous Version
        run: |
          CLUSTER_NAME="hp-analysis-${{ needs.pre-flight.outputs.environment }}-cluster"
          SERVICE_NAME="hp-analysis-${{ needs.pre-flight.outputs.environment }}-app"
          
          # Get deployment history
          DEPLOYMENTS=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].deployments' --output json)
          
          # Find the previous stable deployment
          PREVIOUS_TASK_DEF=$(echo $DEPLOYMENTS | jq -r '
            map(select(.status == "PRIMARY" and .rolloutState == "COMPLETED")) |
            sort_by(.createdAt) | reverse | .[1].taskDefinition
          ')
          
          if [ "$PREVIOUS_TASK_DEF" == "null" ] || [ -z "$PREVIOUS_TASK_DEF" ]; then
            echo "No previous stable deployment found for rollback"
            exit 1
          fi
          
          echo "Rolling back to task definition: $PREVIOUS_TASK_DEF"
          
          # Perform rollback
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $PREVIOUS_TASK_DEF
          
          # Wait for rollback to complete
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME
          
          echo "Rollback completed successfully!"

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [pre-flight, deploy, post-deploy-tests, rollback]
    if: always() && (needs.deploy.result != 'skipped' || needs.rollback.result != 'skipped')
    
    steps:
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          custom_payload: |
            {
              text: `Deployment ${needs.deploy.result || needs.rollback.result} for HP Analysis System`,
              attachments: [{
                color: '${{ job.status }}' === 'success' ? 'good' : '${{ job.status }}' === 'failure' ? 'danger' : 'warning',
                fields: [{
                  title: 'Environment',
                  value: '${{ needs.pre-flight.outputs.environment }}',
                  short: true
                }, {
                  title: 'Branch',
                  value: '${{ github.ref_name }}',
                  short: true
                }, {
                  title: 'Commit',
                  value: '${{ github.sha }}',
                  short: true
                }, {
                  title: 'Actor',
                  value: '${{ github.actor }}',
                  short: true
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}