// Vulnerability Scanner for HP Analysis System
const { execSync, exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const axios = require('axios');

class VulnerabilityScanner {
  constructor() {
    this.scanResults = {
      dependencies: null,
      containers: null,
      infrastructure: null,
      secrets: null,
      timestamp: null
    };
  }

  // Run comprehensive security scan
  async runFullScan() {
    console.log('Starting comprehensive security scan...');
    
    try {
      this.scanResults.timestamp = new Date().toISOString();
      
      // Run all scans in parallel
      const scanPromises = [
        this.scanDependencies(),
        this.scanContainers(),
        this.scanInfrastructure(),
        this.scanSecrets(),
        this.scanCodeQuality()
      ];
      
      const results = await Promise.allSettled(scanPromises);
      
      // Process results
      results.forEach((result, index) => {
        const scanTypes = ['dependencies', 'containers', 'infrastructure', 'secrets', 'codeQuality'];
        if (result.status === 'fulfilled') {
          this.scanResults[scanTypes[index]] = result.value;
        } else {
          console.error(`${scanTypes[index]} scan failed:`, result.reason);
          this.scanResults[scanTypes[index]] = { error: result.reason.message };
        }
      });
      
      // Generate report
      const report = await this.generateReport();
      await this.saveReport(report);
      
      console.log('Security scan completed successfully');
      return this.scanResults;
      
    } catch (error) {
      console.error('Full scan failed:', error);
      throw error;
    }
  }

  // Scan Node.js dependencies for vulnerabilities
  async scanDependencies() {
    console.log('Scanning dependencies...');
    
    try {
      // NPM Audit
      const npmAuditResult = await this.runCommand('npm audit --json', true);
      let npmAudit = {};
      
      if (npmAuditResult.stdout) {
        try {
          npmAudit = JSON.parse(npmAuditResult.stdout);
        } catch (e) {
          console.warn('Failed to parse npm audit output');
        }
      }
      
      // Snyk scan (if token available)
      let snykResult = null;
      if (process.env.SNYK_TOKEN) {
        try {
          const snykOutput = await this.runCommand('npx snyk test --json');
          snykResult = JSON.parse(snykOutput.stdout);
        } catch (error) {
          console.warn('Snyk scan failed:', error.message);
        }
      }
      
      // OWASP Dependency Check
      let owaspResult = null;
      try {
        await this.runCommand('dependency-check --project "HP Analysis System" --scan . --format JSON --out ./security-reports/');
        const owaspPath = './security-reports/dependency-check-report.json';
        if (fs.existsSync(owaspPath)) {
          owaspResult = JSON.parse(fs.readFileSync(owaspPath, 'utf8'));
        }
      } catch (error) {
        console.warn('OWASP Dependency Check failed:', error.message);
      }
      
      return {
        npm: npmAudit,
        snyk: snykResult,
        owasp: owaspResult,
        summary: this.summarizeDependencyVulnerabilities(npmAudit, snykResult, owaspResult)
      };
      
    } catch (error) {
      console.error('Dependency scan failed:', error);
      throw error;
    }
  }

  // Scan Docker containers for vulnerabilities
  async scanContainers() {
    console.log('Scanning containers...');
    
    try {
      const results = {};
      
      // Get list of images to scan
      const images = [
        'hp-analysis-app:latest',
        'hp-analysis-ai-engine:latest'
      ];
      
      for (const image of images) {
        try {
          // Trivy scan
          const trivyResult = await this.runCommand(`trivy image --format json ${image}`);
          const trivyData = JSON.parse(trivyResult.stdout);
          
          // Dockle scan (if available)
          let dockleResult = null;
          try {
            const dockleOutput = await this.runCommand(`dockle --format json ${image}`);
            dockleResult = JSON.parse(dockleOutput.stdout);
          } catch (e) {
            console.warn(`Dockle scan failed for ${image}:`, e.message);
          }
          
          results[image] = {
            trivy: trivyData,
            dockle: dockleResult,
            summary: this.summarizeContainerVulnerabilities(trivyData, dockleResult)
          };
          
        } catch (error) {
          console.warn(`Container scan failed for ${image}:`, error.message);
          results[image] = { error: error.message };
        }
      }
      
      return results;
      
    } catch (error) {
      console.error('Container scan failed:', error);
      throw error;
    }
  }

  // Scan infrastructure (Terraform) for misconfigurations
  async scanInfrastructure() {
    console.log('Scanning infrastructure...');
    
    try {
      const results = {};
      
      // Checkov scan
      try {
        const checkovResult = await this.runCommand('checkov -d terraform/ --framework terraform --output json');
        results.checkov = JSON.parse(checkovResult.stdout);
      } catch (error) {
        console.warn('Checkov scan failed:', error.message);
      }
      
      // TFSec scan
      try {
        const tfsecResult = await this.runCommand('tfsec terraform/ --format json');
        results.tfsec = JSON.parse(tfsecResult.stdout);
      } catch (error) {
        console.warn('TFSec scan failed:', error.message);
      }
      
      // Terrascan
      try {
        const terrascanResult = await this.runCommand('terrascan scan -d terraform/ -o json');
        results.terrascan = JSON.parse(terrascanResult.stdout);
      } catch (error) {
        console.warn('Terrascan failed:', error.message);
      }
      
      return {
        ...results,
        summary: this.summarizeInfrastructureIssues(results)
      };
      
    } catch (error) {
      console.error('Infrastructure scan failed:', error);
      throw error;
    }
  }

  // Scan for secrets in code
  async scanSecrets() {
    console.log('Scanning for secrets...');
    
    try {
      const results = {};
      
      // GitLeaks scan
      try {
        const gitleaksResult = await this.runCommand('gitleaks detect --source . --report-format json --report-path gitleaks-report.json');
        if (fs.existsSync('gitleaks-report.json')) {
          results.gitleaks = JSON.parse(fs.readFileSync('gitleaks-report.json', 'utf8'));
        }
      } catch (error) {
        // GitLeaks returns non-zero exit code when secrets are found
        if (fs.existsSync('gitleaks-report.json')) {
          results.gitleaks = JSON.parse(fs.readFileSync('gitleaks-report.json', 'utf8'));
        } else {
          console.warn('GitLeaks scan failed:', error.message);
        }
      }
      
      // TruffleHog scan
      try {
        const trufflehogResult = await this.runCommand('trufflehog filesystem . --json');
        results.trufflehog = trufflehogResult.stdout.split('\n')
          .filter(line => line.trim())
          .map(line => {
            try {
              return JSON.parse(line);
            } catch (e) {
              return null;
            }
          })
          .filter(item => item !== null);
      } catch (error) {
        console.warn('TruffleHog scan failed:', error.message);
      }
      
      return {
        ...results,
        summary: this.summarizeSecretFindings(results)
      };
      
    } catch (error) {
      console.error('Secrets scan failed:', error);
      throw error;
    }
  }

  // Code quality and security analysis
  async scanCodeQuality() {
    console.log('Scanning code quality...');
    
    try {
      const results = {};
      
      // ESLint security rules
      try {
        const eslintResult = await this.runCommand('npx eslint . --ext .js,.ts --format json');
        results.eslint = JSON.parse(eslintResult.stdout);
      } catch (error) {
        // ESLint returns non-zero for violations
        if (error.stdout) {
          try {
            results.eslint = JSON.parse(error.stdout);
          } catch (e) {
            console.warn('Failed to parse ESLint output');
          }
        }
      }
      
      // Semgrep scan
      if (process.env.SEMGREP_APP_TOKEN) {
        try {
          const semgrepResult = await this.runCommand('semgrep --config=auto --json .');
          results.semgrep = JSON.parse(semgrepResult.stdout);
        } catch (error) {
          console.warn('Semgrep scan failed:', error.message);
        }
      }
      
      return {
        ...results,
        summary: this.summarizeCodeQualityIssues(results)
      };
      
    } catch (error) {
      console.error('Code quality scan failed:', error);
      throw error;
    }
  }

  // Helper method to run shell commands
  runCommand(command, allowFailure = false) {
    return new Promise((resolve, reject) => {
      exec(command, { maxBuffer: 1024 * 1024 * 10 }, (error, stdout, stderr) => {
        if (error && !allowFailure) {
          reject({ error, stdout, stderr });
        } else {
          resolve({ stdout, stderr, error });
        }
      });
    });
  }

  // Summarize dependency vulnerabilities
  summarizeDependencyVulnerabilities(npmAudit, snykResult, owaspResult) {
    let total = 0;
    let critical = 0;
    let high = 0;
    let medium = 0;
    let low = 0;
    
    // NPM audit summary
    if (npmAudit && npmAudit.metadata && npmAudit.metadata.vulnerabilities) {
      const vulns = npmAudit.metadata.vulnerabilities;
      critical += vulns.critical || 0;
      high += vulns.high || 0;
      medium += vulns.moderate || 0;
      low += vulns.low || 0;
      total = critical + high + medium + low;
    }
    
    return { total, critical, high, medium, low };
  }

  // Summarize container vulnerabilities
  summarizeContainerVulnerabilities(trivyData, dockleData) {
    let total = 0;
    let critical = 0;
    let high = 0;
    let medium = 0;
    let low = 0;
    
    if (trivyData && trivyData.Results) {
      trivyData.Results.forEach(result => {
        if (result.Vulnerabilities) {
          result.Vulnerabilities.forEach(vuln => {
            total++;
            switch (vuln.Severity?.toLowerCase()) {
              case 'critical': critical++; break;
              case 'high': high++; break;
              case 'medium': medium++; break;
              case 'low': low++; break;
            }
          });
        }
      });
    }
    
    return { total, critical, high, medium, low };
  }

  // Summarize infrastructure issues
  summarizeInfrastructureIssues(results) {
    let total = 0;
    let critical = 0;
    let high = 0;
    let medium = 0;
    let low = 0;
    
    // Process results from different tools
    Object.values(results).forEach(result => {
      if (result && Array.isArray(result)) {
        result.forEach(issue => {
          total++;
          switch (issue.severity?.toLowerCase() || issue.rule_severity?.toLowerCase()) {
            case 'critical': critical++; break;
            case 'high': high++; break;
            case 'medium': medium++; break;
            case 'low': low++; break;
          }
        });
      }
    });
    
    return { total, critical, high, medium, low };
  }

  // Summarize secret findings
  summarizeSecretFindings(results) {
    let total = 0;
    
    if (results.gitleaks && Array.isArray(results.gitleaks)) {
      total += results.gitleaks.length;
    }
    
    if (results.trufflehog && Array.isArray(results.trufflehog)) {
      total += results.trufflehog.length;
    }
    
    return { total };
  }

  // Summarize code quality issues
  summarizeCodeQualityIssues(results) {
    let total = 0;
    let errors = 0;
    let warnings = 0;
    
    if (results.eslint && Array.isArray(results.eslint)) {
      results.eslint.forEach(file => {
        if (file.messages) {
          file.messages.forEach(msg => {
            total++;
            if (msg.severity === 2) errors++;
            else if (msg.severity === 1) warnings++;
          });
        }
      });
    }
    
    return { total, errors, warnings };
  }

  // Generate comprehensive report
  async generateReport() {
    const report = {
      metadata: {
        timestamp: this.scanResults.timestamp,
        version: '1.0',
        system: 'HP Analysis System'
      },
      summary: {
        dependencies: this.scanResults.dependencies?.summary || {},
        containers: this.extractContainerSummary(),
        infrastructure: this.scanResults.infrastructure?.summary || {},
        secrets: this.scanResults.secrets?.summary || {},
        codeQuality: this.scanResults.codeQuality?.summary || {}
      },
      details: this.scanResults,
      recommendations: this.generateRecommendations()
    };
    
    return report;
  }

  // Extract container summary
  extractContainerSummary() {
    if (!this.scanResults.containers) return {};
    
    let total = 0;
    let critical = 0;
    let high = 0;
    let medium = 0;
    let low = 0;
    
    Object.values(this.scanResults.containers).forEach(container => {
      if (container.summary) {
        total += container.summary.total || 0;
        critical += container.summary.critical || 0;
        high += container.summary.high || 0;
        medium += container.summary.medium || 0;
        low += container.summary.low || 0;
      }
    });
    
    return { total, critical, high, medium, low };
  }

  // Generate security recommendations
  generateRecommendations() {
    const recommendations = [];
    
    // Dependency recommendations
    const depSummary = this.scanResults.dependencies?.summary;
    if (depSummary && depSummary.total > 0) {
      if (depSummary.critical > 0) {
        recommendations.push({
          priority: 'critical',
          category: 'dependencies',
          message: `${depSummary.critical} critical vulnerabilities found in dependencies. Update immediately.`
        });
      }
      if (depSummary.high > 0) {
        recommendations.push({
          priority: 'high',
          category: 'dependencies',
          message: `${depSummary.high} high-severity vulnerabilities found. Plan updates within 7 days.`
        });
      }
    }
    
    // Container recommendations
    const containerSummary = this.extractContainerSummary();
    if (containerSummary.critical > 0) {
      recommendations.push({
        priority: 'critical',
        category: 'containers',
        message: `${containerSummary.critical} critical vulnerabilities in container images. Rebuild with updated base images.`
      });
    }
    
    // Secrets recommendations
    const secretsSummary = this.scanResults.secrets?.summary;
    if (secretsSummary && secretsSummary.total > 0) {
      recommendations.push({
        priority: 'critical',
        category: 'secrets',
        message: `${secretsSummary.total} potential secrets found in code. Review and remove immediately.`
      });
    }
    
    return recommendations;
  }

  // Save report to file
  async saveReport(report) {
    const reportsDir = './security-reports';
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportPath = path.join(reportsDir, `security-report-${timestamp}.json`);
    
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log(`Security report saved to: ${reportPath}`);
    
    // Also save a latest report
    const latestPath = path.join(reportsDir, 'security-report-latest.json');
    fs.writeFileSync(latestPath, JSON.stringify(report, null, 2));
    
    return reportPath;
  }
}

// CLI interface
if (require.main === module) {
  const scanner = new VulnerabilityScanner();
  
  scanner.runFullScan()
    .then(results => {
      console.log('\nScan completed successfully!');
      console.log('Summary:', JSON.stringify(results, null, 2));
      process.exit(0);
    })
    .catch(error => {
      console.error('Scan failed:', error);
      process.exit(1);
    });
}

module.exports = VulnerabilityScanner;