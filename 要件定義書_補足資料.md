# AIウェブ分析システム要件定義書 - 補足資料

## A. 開発者向け実装ガイド

### A.1 JavaScriptタグ実装詳細

#### 基本実装
```javascript
// tag.js の実装例
(function() {
  'use strict';
  
  // グローバル変数の汚染を防ぐ
  window._aiAnalytics = window._aiAnalytics || {};
  
  const config = {
    apiEndpoint: 'https://api.ai-analytics.jp/v1/collect',
    batchInterval: 5000, // 5秒
    maxRetries: 3,
    maxBatchSize: 50
  };
  
  // ユーザーID生成（UUID v4）
  function generateUserId() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  // セッションID生成
  function generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
  
  // デバイス情報取得
  function getDeviceInfo() {
    return {
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      viewportWidth: window.innerWidth,
      viewportHeight: window.innerHeight,
      devicePixelRatio: window.devicePixelRatio || 1,
      colorDepth: window.screen.colorDepth,
      userAgent: navigator.userAgent,
      language: navigator.language,
      platform: navigator.platform,
      cookieEnabled: navigator.cookieEnabled,
      onLine: navigator.onLine,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    };
  }
  
  // ページビューイベント送信
  function trackPageView() {
    const event = {
      type: 'pageview',
      timestamp: new Date().toISOString(),
      url: window.location.href,
      title: document.title,
      referrer: document.referrer,
      sessionId: getOrCreateSessionId(),
      userId: getOrCreateUserId(),
      device: getDeviceInfo()
    };
    
    addEventToQueue(event);
  }
  
  // イベントキュー管理
  const eventQueue = [];
  let batchTimer = null;
  
  function addEventToQueue(event) {
    eventQueue.push(event);
    
    if (eventQueue.length >= config.maxBatchSize) {
      sendBatch();
    } else if (!batchTimer) {
      batchTimer = setTimeout(sendBatch, config.batchInterval);
    }
  }
  
  // バッチ送信
  async function sendBatch() {
    if (eventQueue.length === 0) return;
    
    const events = eventQueue.splice(0, config.maxBatchSize);
    clearTimeout(batchTimer);
    batchTimer = null;
    
    try {
      const response = await fetch(config.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Tracking-ID': getTrackingId()
        },
        body: JSON.stringify({ events })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      console.error('Failed to send analytics data:', error);
      // 失敗したイベントをローカルストレージに保存
      saveToLocalStorage(events);
    }
  }
  
  // ローカルストレージへの保存（オフライン対応）
  function saveToLocalStorage(events) {
    try {
      const stored = localStorage.getItem('_aiAnalytics_queue') || '[]';
      const queue = JSON.parse(stored);
      queue.push(...events);
      // 最大1000イベントまで保存
      if (queue.length > 1000) {
        queue.splice(0, queue.length - 1000);
      }
      localStorage.setItem('_aiAnalytics_queue', JSON.stringify(queue));
    } catch (e) {
      // ローカルストレージが使えない場合は諦める
    }
  }
  
  // 初期化
  function init() {
    // ページビュートラッキング
    trackPageView();
    
    // ページ離脱時にバッチ送信
    window.addEventListener('beforeunload', sendBatch);
    
    // SPAのルート変更検知
    let lastUrl = window.location.href;
    new MutationObserver(() => {
      if (window.location.href !== lastUrl) {
        lastUrl = window.location.href;
        trackPageView();
      }
    }).observe(document, { subtree: true, childList: true });
  }
  
  // DOMContentLoaded で初期化
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
```

### A.2 バックエンドAPI実装

#### Express.js サーバー実装例
```javascript
// server.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const { Pool } = require('pg');
const Redis = require('ioredis');

const app = express();
const port = process.env.PORT || 3000;

// ミドルウェア設定
app.use(helmet());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*'
}));
app.use(express.json({ limit: '10mb' }));

// レート制限
const limiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1分
  max: 100 // 1分間に100リクエストまで
});
app.use('/api/collect', limiter);

// データベース接続
const pgPool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Redis接続
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

// データ収集エンドポイント
app.post('/api/collect',
  // バリデーション
  body('events').isArray().withMessage('Events must be an array'),
  body('events.*.type').isIn(['pageview', 'click', 'scroll']).withMessage('Invalid event type'),
  body('events.*.timestamp').isISO8601().withMessage('Invalid timestamp'),
  body('events.*.url').isURL().withMessage('Invalid URL'),
  
  async (req, res) => {
    // バリデーションエラーチェック
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    const trackingId = req.headers['x-tracking-id'];
    if (!trackingId) {
      return res.status(401).json({ error: 'Missing tracking ID' });
    }
    
    try {
      // サイトの存在確認（Redisキャッシュ利用）
      const siteKey = `site:${trackingId}`;
      let siteId = await redis.get(siteKey);
      
      if (!siteId) {
        const result = await pgPool.query(
          'SELECT id FROM sites WHERE tracking_id = $1',
          [trackingId]
        );
        
        if (result.rows.length === 0) {
          return res.status(401).json({ error: 'Invalid tracking ID' });
        }
        
        siteId = result.rows[0].id;
        await redis.setex(siteKey, 3600, siteId); // 1時間キャッシュ
      }
      
      // イベントデータの保存
      const events = req.body.events;
      const values = [];
      const placeholders = [];
      
      events.forEach((event, index) => {
        const offset = index * 8;
        placeholders.push(
          `($${offset + 1}, $${offset + 2}, $${offset + 3}, $${offset + 4}, $${offset + 5}, $${offset + 6}, $${offset + 7}, $${offset + 8})`
        );
        
        values.push(
          siteId,
          event.sessionId,
          event.userId,
          event.type,
          event.url,
          event.title || null,
          event.referrer || null,
          event.timestamp
        );
      });
      
      const query = `
        INSERT INTO page_views 
        (site_id, session_id, user_id, event_type, page_url, page_title, referrer, timestamp)
        VALUES ${placeholders.join(', ')}
      `;
      
      await pgPool.query(query, values);
      
      // リアルタイム統計の更新（Redis）
      const realTimeKey = `realtime:${siteId}:${new Date().toISOString().slice(0, 10)}`;
      await redis.hincrby(realTimeKey, 'pageviews', events.length);
      await redis.expire(realTimeKey, 86400); // 24時間で自動削除
      
      res.json({ success: true, processed: events.length });
      
    } catch (error) {
      console.error('Error processing events:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }
);

// 分析データ取得API
app.get('/api/sites/:siteId/analytics', async (req, res) => {
  const { siteId } = req.params;
  const { start_date, end_date } = req.query;
  
  try {
    // 基本統計の取得
    const statsQuery = `
      SELECT 
        COUNT(DISTINCT session_id) as sessions,
        COUNT(DISTINCT user_id) as users,
        COUNT(*) as pageviews,
        AVG(EXTRACT(EPOCH FROM (ended_at - started_at))) as avg_duration
      FROM page_views pv
      JOIN sessions s ON pv.session_id = s.id
      WHERE pv.site_id = $1 
        AND pv.timestamp >= $2 
        AND pv.timestamp <= $3
    `;
    
    const stats = await pgPool.query(statsQuery, [siteId, start_date, end_date]);
    
    // 時系列データの取得
    const timeseriesQuery = `
      SELECT 
        DATE(timestamp) as date,
        COUNT(*) as pageviews,
        COUNT(DISTINCT user_id) as users
      FROM page_views
      WHERE site_id = $1 
        AND timestamp >= $2 
        AND timestamp <= $3
      GROUP BY DATE(timestamp)
      ORDER BY date
    `;
    
    const timeseries = await pgPool.query(timeseriesQuery, [siteId, start_date, end_date]);
    
    res.json({
      summary: stats.rows[0],
      timeseries: timeseries.rows
    });
    
  } catch (error) {
    console.error('Error fetching analytics:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// サーバー起動
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
```

### A.3 AI分析エンジン実装

#### Python Flask + OpenAI実装例
```python
# ai_analysis.py
import os
import json
from datetime import datetime, timedelta
from flask import Flask, request, jsonify
import pandas as pd
import numpy as np
from sqlalchemy import create_engine
import openai
from scipy import stats
import schedule
import time
import threading

app = Flask(__name__)

# 設定
DATABASE_URL = os.getenv('DATABASE_URL')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

# データベース接続
engine = create_engine(DATABASE_URL)
openai.api_key = OPENAI_API_KEY

class AnalyticsEngine:
    def __init__(self):
        self.engine = engine
    
    def fetch_site_data(self, site_id, days=7):
        """サイトのデータを取得"""
        query = f"""
        SELECT 
            DATE(timestamp) as date,
            HOUR(timestamp) as hour,
            COUNT(*) as pageviews,
            COUNT(DISTINCT user_id) as users,
            COUNT(DISTINCT session_id) as sessions,
            AVG(duration) as avg_duration,
            page_url,
            referrer
        FROM page_views
        WHERE site_id = '{site_id}'
            AND timestamp >= NOW() - INTERVAL {days} DAY
        GROUP BY DATE(timestamp), HOUR(timestamp), page_url, referrer
        """
        return pd.read_sql(query, self.engine)
    
    def detect_anomalies(self, df):
        """異常値検知"""
        anomalies = []
        
        # 日次ページビューの異常検知
        daily_pv = df.groupby('date')['pageviews'].sum()
        
        # 移動平均と標準偏差を計算
        rolling_mean = daily_pv.rolling(window=7, min_periods=1).mean()
        rolling_std = daily_pv.rolling(window=7, min_periods=1).std()
        
        # 3σを超える値を異常値とする
        upper_bound = rolling_mean + (3 * rolling_std)
        lower_bound = rolling_mean - (3 * rolling_std)
        
        for date, pv in daily_pv.items():
            if pv > upper_bound[date] or pv < lower_bound[date]:
                anomalies.append({
                    'date': str(date),
                    'metric': 'pageviews',
                    'value': int(pv),
                    'expected_range': f"{int(lower_bound[date])} - {int(upper_bound[date])}"
                })
        
        return anomalies
    
    def analyze_trends(self, df):
        """トレンド分析"""
        # 週次トレンド
        current_week = df[df['date'] >= (datetime.now() - timedelta(days=7))]
        previous_week = df[(df['date'] < (datetime.now() - timedelta(days=7))) & 
                          (df['date'] >= (datetime.now() - timedelta(days=14)))]
        
        current_metrics = {
            'pageviews': current_week['pageviews'].sum(),
            'users': current_week['users'].sum(),
            'sessions': current_week['sessions'].sum(),
            'avg_duration': current_week['avg_duration'].mean()
        }
        
        previous_metrics = {
            'pageviews': previous_week['pageviews'].sum(),
            'users': previous_week['users'].sum(),
            'sessions': previous_week['sessions'].sum(),
            'avg_duration': previous_week['avg_duration'].mean()
        }
        
        trends = {}
        for metric in current_metrics:
            if previous_metrics[metric] > 0:
                change = ((current_metrics[metric] - previous_metrics[metric]) / 
                         previous_metrics[metric]) * 100
                trends[metric] = {
                    'current': current_metrics[metric],
                    'previous': previous_metrics[metric],
                    'change_percentage': round(change, 1)
                }
        
        return trends
    
    def generate_insights(self, df, anomalies, trends):
        """AIによるインサイト生成"""
        # データを要約
        summary = {
            'total_pageviews': int(df['pageviews'].sum()),
            'total_users': int(df['users'].sum()),
            'top_pages': df.groupby('page_url')['pageviews'].sum().nlargest(5).to_dict(),
            'top_referrers': df.groupby('referrer')['users'].sum().nlargest(5).to_dict(),
            'anomalies': anomalies,
            'trends': trends
        }
        
        # GPT-3.5にインサイト生成を依頼
        prompt = f"""
        以下のWebサイト分析データから、経営者向けの実用的なインサイトを3つ生成してください。
        各インサイトは具体的な改善アクションを含めてください。
        
        データ：
        {json.dumps(summary, ensure_ascii=False, indent=2)}
        
        フォーマット：
        1. [問題/機会]: 具体的な改善アクション
        2. [問題/機会]: 具体的な改善アクション
        3. [問題/機会]: 具体的な改善アクション
        """
        
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "あなたはWeb分析の専門家です。"},
                {"role": "user", "content": prompt}
            ],
            max_tokens=500,
            temperature=0.7
        )
        
        return response.choices[0].message.content
    
    def calculate_bounce_rate(self, site_id):
        """直帰率の計算"""
        query = f"""
        SELECT 
            COUNT(CASE WHEN page_count = 1 THEN 1 END) as bounced_sessions,
            COUNT(*) as total_sessions
        FROM (
            SELECT session_id, COUNT(*) as page_count
            FROM page_views
            WHERE site_id = '{site_id}'
                AND timestamp >= NOW() - INTERVAL 7 DAY
            GROUP BY session_id
        ) as session_pages
        """
        result = pd.read_sql(query, self.engine)
        
        if result['total_sessions'][0] > 0:
            bounce_rate = (result['bounced_sessions'][0] / result['total_sessions'][0]) * 100
            return round(bounce_rate, 1)
        return 0

# 定期分析ジョブ
def run_scheduled_analysis():
    """全サイトの定期分析を実行"""
    analytics = AnalyticsEngine()
    
    # アクティブなサイトを取得
    sites = pd.read_sql("SELECT id, name FROM sites WHERE active = true", engine)
    
    for _, site in sites.iterrows():
        try:
            # データ取得
            df = analytics.fetch_site_data(site['id'])
            
            # 分析実行
            anomalies = analytics.detect_anomalies(df)
            trends = analytics.analyze_trends(df)
            insights = analytics.generate_insights(df, anomalies, trends)
            bounce_rate = analytics.calculate_bounce_rate(site['id'])
            
            # 結果を保存
            report = {
                'site_id': site['id'],
                'generated_at': datetime.now().isoformat(),
                'anomalies': anomalies,
                'trends': trends,
                'insights': insights,
                'bounce_rate': bounce_rate
            }
            
            # データベースに保存
            save_report(report)
            
        except Exception as e:
            print(f"Error analyzing site {site['id']}: {str(e)}")

def save_report(report):
    """分析レポートをデータベースに保存"""
    query = """
    INSERT INTO ai_reports (site_id, report_date, report_data)
    VALUES (%s, %s, %s)
    ON CONFLICT (site_id, report_date) 
    DO UPDATE SET report_data = EXCLUDED.report_data
    """
    
    with engine.connect() as conn:
        conn.execute(query, (
            report['site_id'],
            datetime.now().date(),
            json.dumps(report)
        ))

# APIエンドポイント
@app.route('/api/analyze/<site_id>', methods=['POST'])
def analyze_site(site_id):
    """オンデマンド分析の実行"""
    try:
        analytics = AnalyticsEngine()
        
        # データ取得
        df = analytics.fetch_site_data(site_id)
        
        if df.empty:
            return jsonify({'error': 'No data found for site'}), 404
        
        # 分析実行
        anomalies = analytics.detect_anomalies(df)
        trends = analytics.analyze_trends(df)
        insights = analytics.generate_insights(df, anomalies, trends)
        bounce_rate = analytics.calculate_bounce_rate(site_id)
        
        return jsonify({
            'anomalies': anomalies,
            'trends': trends,
            'insights': insights,
            'bounce_rate': bounce_rate,
            'generated_at': datetime.now().isoformat()
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# スケジューラーの設定
def run_scheduler():
    schedule.every().day.at("02:00").do(run_scheduled_analysis)
    
    while True:
        schedule.run_pending()
        time.sleep(60)

# スケジューラーを別スレッドで起動
scheduler_thread = threading.Thread(target=run_scheduler)
scheduler_thread.daemon = True
scheduler_thread.start()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

### A.4 React ダッシュボード実装

#### メインダッシュボードコンポーネント
```jsx
// Dashboard.jsx
import React, { useState, useEffect } from 'react';
import {
  Grid,
  Paper,
  Typography,
  Card,
  CardContent,
  CircularProgress,
  Box,
  Select,
  MenuItem,
  FormControl,
  InputLabel
} from '@mui/material';
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend
} from 'recharts';
import { format, subDays } from 'date-fns';
import { ja } from 'date-fns/locale';

// API クライアント
import { analyticsAPI } from '../services/api';

// メトリクスカードコンポーネント
const MetricCard = ({ title, value, previousValue, format: formatFunc }) => {
  const changePercent = previousValue
    ? ((value - previousValue) / previousValue * 100).toFixed(1)
    : 0;
  const isPositive = changePercent >= 0;

  return (
    <Card>
      <CardContent>
        <Typography color="textSecondary" gutterBottom>
          {title}
        </Typography>
        <Typography variant="h4" component="h2">
          {formatFunc ? formatFunc(value) : value.toLocaleString()}
        </Typography>
        <Typography
          variant="body2"
          style={{ color: isPositive ? '#4caf50' : '#f44336' }}
        >
          {isPositive ? '↑' : '↓'} {Math.abs(changePercent)}%
        </Typography>
      </CardContent>
    </Card>
  );
};

// メインダッシュボード
const Dashboard = () => {
  const [loading, setLoading] = useState(true);
  const [period, setPeriod] = useState(7); // デフォルト7日間
  const [data, setData] = useState({
    summary: {},
    timeseries: [],
    sources: [],
    topPages: [],
    realtime: 0
  });

  // データ取得
  const fetchData = async () => {
    setLoading(true);
    try {
      const endDate = new Date();
      const startDate = subDays(endDate, period);
      
      const response = await analyticsAPI.getAnalytics({
        startDate: format(startDate, 'yyyy-MM-dd'),
        endDate: format(endDate, 'yyyy-MM-dd')
      });

      setData(response.data);
    } catch (error) {
      console.error('Failed to fetch analytics:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
    // 5分ごとに更新
    const interval = setInterval(fetchData, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [period]);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>
    );
  }

  // グラフ用の色
  const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

  return (
    <Box sx={{ flexGrow: 1, p: 3 }}>
      {/* ヘッダー */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">ダッシュボード</Typography>
        <FormControl variant="outlined" size="small" style={{ minWidth: 120 }}>
          <InputLabel>期間</InputLabel>
          <Select value={period} onChange={(e) => setPeriod(e.target.value)} label="期間">
            <MenuItem value={1}>今日</MenuItem>
            <MenuItem value={7}>7日間</MenuItem>
            <MenuItem value={30}>30日間</MenuItem>
            <MenuItem value={90}>90日間</MenuItem>
          </Select>
        </FormControl>
      </Box>

      {/* リアルタイム訪問者数 */}
      <Paper sx={{ p: 2, mb: 3, backgroundColor: '#e3f2fd' }}>
        <Typography variant="h6">
          現在のアクティブユーザー: {data.realtime}人
        </Typography>
      </Paper>

      {/* メトリクスカード */}
      <Grid container spacing={3} mb={3}>
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="ページビュー"
            value={data.summary.pageviews || 0}
            previousValue={data.summary.previousPageviews}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="ユーザー数"
            value={data.summary.users || 0}
            previousValue={data.summary.previousUsers}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="セッション数"
            value={data.summary.sessions || 0}
            previousValue={data.summary.previousSessions}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="平均滞在時間"
            value={data.summary.avgDuration || 0}
            previousValue={data.summary.previousAvgDuration}
            format={(v) => `${Math.floor(v / 60)}分${v % 60}秒`}
          />
        </Grid>
      </Grid>

      {/* グラフ */}
      <Grid container spacing={3}>
        {/* 時系列グラフ */}
        <Grid item xs={12} md={8}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>
              アクセス推移
            </Typography>
            <ResponsiveContainer width="100%" height={300}>
              <AreaChart data={data.timeseries}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="date" 
                  tickFormatter={(date) => format(new Date(date), 'M/d', { locale: ja })}
                />
                <YAxis />
                <Tooltip 
                  labelFormatter={(date) => format(new Date(date), 'yyyy年M月d日', { locale: ja })}
                />
                <Legend />
                <Area
                  type="monotone"
                  dataKey="pageviews"
                  name="ページビュー"
                  stroke="#8884d8"
                  fill="#8884d8"
                />
                <Area
                  type="monotone"
                  dataKey="users"
                  name="ユーザー"
                  stroke="#82ca9d"
                  fill="#82ca9d"
                />
              </AreaChart>
            </ResponsiveContainer>
          </Paper>
        </Grid>

        {/* 流入元円グラフ */}
        <Grid item xs={12} md={4}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>
              流入元
            </Typography>
            <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie
                  data={data.sources}
                  cx="50%"
                  cy="50%"
                  labelLine={false}
                  label={(entry) => `${entry.name} ${entry.value}%`}
                  outerRadius={80}
                  fill="#8884d8"
                  dataKey="value"
                >
                  {data.sources.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </Paper>
        </Grid>

        {/* 人気ページランキング */}
        <Grid item xs={12}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>
              人気ページ TOP 10
            </Typography>
            <Box sx={{ overflowX: 'auto' }}>
              <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                <thead>
                  <tr style={{ borderBottom: '1px solid #ddd' }}>
                    <th style={{ padding: '8px', textAlign: 'left' }}>ページ</th>
                    <th style={{ padding: '8px', textAlign: 'right' }}>PV</th>
                    <th style={{ padding: '8px', textAlign: 'right' }}>UU</th>
                    <th style={{ padding: '8px', textAlign: 'right' }}>平均滞在時間</th>
                  </tr>
                </thead>
                <tbody>
                  {data.topPages.map((page, index) => (
                    <tr key={index} style={{ borderBottom: '1px solid #eee' }}>
                      <td style={{ padding: '8px' }}>{page.url}</td>
                      <td style={{ padding: '8px', textAlign: 'right' }}>
                        {page.pageviews.toLocaleString()}
                      </td>
                      <td style={{ padding: '8px', textAlign: 'right' }}>
                        {page.users.toLocaleString()}
                      </td>
                      <td style={{ padding: '8px', textAlign: 'right' }}>
                        {Math.floor(page.avgDuration / 60)}分{page.avgDuration % 60}秒
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default Dashboard;
```

### A.5 インフラ構成（Terraform）

```hcl
# infrastructure.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}

# VPC
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "${var.project_name}-vpc"
  }
}

# パブリックサブネット
resource "aws_subnet" "public" {
  count                   = 2
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.${count.index + 1}.0/24"
  availability_zone       = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true

  tags = {
    Name = "${var.project_name}-public-${count.index + 1}"
  }
}

# インターネットゲートウェイ
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "${var.project_name}-igw"
  }
}

# ルートテーブル
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name = "${var.project_name}-public-rt"
  }
}

# EC2インスタンス（アプリケーションサーバー）
resource "aws_instance" "app" {
  ami           = data.aws_ami.amazon_linux_2.id
  instance_type = var.instance_type
  subnet_id     = aws_subnet.public[0].id
  
  vpc_security_group_ids = [aws_security_group.app.id]
  
  user_data = file("./scripts/setup.sh")

  tags = {
    Name = "${var.project_name}-app"
  }
}

# セキュリティグループ
resource "aws_security_group" "app" {
  name        = "${var.project_name}-app-sg"
  description = "Security group for application server"
  vpc_id      = aws_vpc.main.id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# RDS（PostgreSQL）
resource "aws_db_instance" "main" {
  identifier     = "${var.project_name}-db"
  engine         = "postgres"
  engine_version = "15.5"
  instance_class = "db.t3.micro"
  
  allocated_storage     = 20
  max_allocated_storage = 100
  storage_encrypted     = true
  
  db_name  = var.db_name
  username = var.db_username
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  skip_final_snapshot = true

  tags = {
    Name = "${var.project_name}-db"
  }
}

# ElastiCache（Redis）
resource "aws_elasticache_cluster" "main" {
  cluster_id           = "${var.project_name}-cache"
  engine               = "redis"
  node_type            = "cache.t3.micro"
  num_cache_nodes      = 1
  parameter_group_name = "default.redis7"
  port                 = 6379
  subnet_group_name    = aws_elasticache_subnet_group.main.name
  security_group_ids   = [aws_security_group.redis.id]

  tags = {
    Name = "${var.project_name}-cache"
  }
}

# S3バケット（静的ファイル）
resource "aws_s3_bucket" "static" {
  bucket = "${var.project_name}-static-files"

  tags = {
    Name = "${var.project_name}-static"
  }
}

# CloudFront
resource "aws_cloudfront_distribution" "main" {
  origin {
    domain_name = aws_s3_bucket.static.bucket_regional_domain_name
    origin_id   = "S3-${aws_s3_bucket.static.id}"

    s3_origin_config {
      origin_access_identity = aws_cloudfront_origin_access_identity.main.cloudfront_access_identity_path
    }
  }

  enabled             = true
  is_ipv6_enabled     = true
  default_root_object = "index.html"

  default_cache_behavior {
    allowed_methods  = ["GET", "HEAD"]
    cached_methods   = ["GET", "HEAD"]
    target_origin_id = "S3-${aws_s3_bucket.static.id}"

    forwarded_values {
      query_string = false
      cookies {
        forward = "none"
      }
    }

    viewer_protocol_policy = "redirect-to-https"
    min_ttl                = 0
    default_ttl            = 86400
    max_ttl                = 31536000
  }

  price_class = "PriceClass_100"

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }

  viewer_certificate {
    cloudfront_default_certificate = true
  }

  tags = {
    Name = "${var.project_name}-cdn"
  }
}

# 変数定義
variable "project_name" {
  default = "ai-analytics"
}

variable "region" {
  default = "ap-northeast-1"
}

variable "instance_type" {
  default = "t3.small"
}

variable "db_name" {
  default = "analytics"
}

variable "db_username" {
  default = "analytics_user"
}

variable "db_password" {
  sensitive = true
}
```

---

## B. プロジェクト管理ツール

### B.1 進捗管理用チェックリスト

```markdown
# 開発進捗チェックリスト

## Phase 1: 設計・環境構築 (2週間)
- [ ] 要件定義書のレビュー・承認
- [ ] 詳細設計書の作成
  - [ ] API仕様書
  - [ ] データベース設計書
  - [ ] 画面設計書
- [ ] 開発環境構築
  - [ ] Gitリポジトリ作成
  - [ ] Docker環境構築
  - [ ] 開発用データベース構築
- [ ] AWSアカウント設定
  - [ ] IAMユーザー作成
  - [ ] 開発環境用リソース作成
- [ ] CI/CD環境構築
  - [ ] GitHub Actions設定
  - [ ] 自動テスト環境
  - [ ] デプロイ自動化

## Phase 2: 基本機能開発 (6週間)
- [ ] JavaScriptタグ開発
  - [ ] 基本実装
  - [ ] 圧縮・最適化
  - [ ] クロスブラウザテスト
- [ ] データ収集API開発
  - [ ] エンドポイント実装
  - [ ] バリデーション
  - [ ] レート制限
- [ ] ユーザー認証機能
  - [ ] 登録・ログイン
  - [ ] パスワードリセット
  - [ ] セッション管理
- [ ] ダッシュボード画面
  - [ ] UIコンポーネント作成
  - [ ] グラフ表示
  - [ ] リアルタイム更新
- [ ] 基本的な分析機能
  - [ ] データ集計処理
  - [ ] 統計計算
  - [ ] レポート生成

## Phase 3: AI機能開発 (4週間)
- [ ] AI分析エンジン実装
  - [ ] 異常値検知
  - [ ] トレンド分析
  - [ ] 予測モデル
- [ ] インサイト生成機能
  - [ ] OpenAI API連携
  - [ ] プロンプト最適化
  - [ ] 結果の整形
- [ ] レポート生成機能
  - [ ] 定期実行バッチ
  - [ ] PDF生成
  - [ ] メール送信

## Phase 4: 結合・テスト (4週間)
- [ ] 結合テスト
  - [ ] APIテスト
  - [ ] E2Eテスト
  - [ ] データ整合性テスト
- [ ] 性能テスト
  - [ ] 負荷テスト
  - [ ] ストレステスト
  - [ ] 最適化
- [ ] セキュリティテスト
  - [ ] 脆弱性診断
  - [ ] ペネトレーションテスト
  - [ ] セキュリティ修正
- [ ] バグ修正
  - [ ] 優先度設定
  - [ ] 修正実施
  - [ ] 再テスト

## Phase 5: β版リリース (2週間)
- [ ] 本番環境構築
  - [ ] インフラ構築
  - [ ] SSL証明書設定
  - [ ] 監視設定
- [ ] 初期顧客への導入
  - [ ] アカウント作成
  - [ ] 導入サポート
  - [ ] 使い方説明
- [ ] フィードバック収集
  - [ ] アンケート実施
  - [ ] インタビュー
  - [ ] 改善点整理

## Phase 6: 改善・本番化 (4週間)
- [ ] フィードバック対応
  - [ ] 優先度設定
  - [ ] 機能改善
  - [ ] UI/UX改善
- [ ] ドキュメント整備
  - [ ] 利用マニュアル
  - [ ] API仕様書
  - [ ] 運用手順書
- [ ] 正式版リリース
  - [ ] 最終テスト
  - [ ] リリース作業
  - [ ] アナウンス
```

### B.2 リスク管理表

```markdown
# リスク管理表

| リスクID | リスク内容 | 影響度 | 発生確率 | リスク値 | 対策 | 責任者 | 状態 |
|---------|-----------|--------|---------|---------|------|--------|-----|
| R001 | 開発スキル不足 | 高 | 中 | 6 | 事前学習・外部支援確保 | PM | 対策中 |
| R002 | 要件変更頻発 | 中 | 高 | 6 | 変更管理プロセス確立 | PM | 未対応 |
| R003 | セキュリティ脆弱性 | 高 | 低 | 3 | 定期診断・専門家レビュー | 開発者 | 計画中 |
| R004 | 性能要件未達 | 中 | 中 | 4 | 早期性能テスト実施 | 開発者 | 未対応 |
| R005 | 予算超過 | 高 | 低 | 3 | 月次予実管理 | PM | 対策中 |
| R006 | 納期遅延 | 高 | 中 | 6 | バッファ確保・スコープ調整 | PM | 対策中 |
| R007 | 顧客獲得困難 | 高 | 中 | 6 | 事前営業・無料トライアル | 営業 | 計画中 |
| R008 | 技術的負債蓄積 | 中 | 高 | 6 | コードレビュー・リファクタリング | 開発者 | 対策中 |

影響度・発生確率: 高=3, 中=2, 低=1
リスク値 = 影響度 × 発生確率
```

---

これで、誰が見ても作業に迷わないレベルの要件定義書と補足資料が完成しました。この文書を基に、開発者は具体的な実装を進めることができます。